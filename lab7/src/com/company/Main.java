package com.company;
/*
Задача:Отсортируйте массив по частоте элементов: то есть, элементы,
       которые имеют более высокую частоту, должны находиться на первом месте.
       Если частоты двух элементов одинаковы, то меньшее число идет первым.
       Для решения этой задачи используйте хэш-таблицы.
    Для решения этой задачи поместим все элементы в особую хэш-таблицу. Её особенность заключается в том, что
    значение для каждого ключа является его частотой(это реализовано с помощью метода putforfrequency класса SeparateChainingHashST_).
    Этот метод отличается от обычного put тем, что если мы помещаем ключ, который уже есть в таблице, то мы не меняем значение
    для этого ключа, а увеличиваем значение на 1(так как этот ключ уже был, и его частоту нужно увеличить).
    Далее мы под все возможные частоты выделяем очередь с минимальным приоритетом(так как если частота одинаковая, первым
    должен идти минимум) и вставляем каждый ключ из таблицы в очередь с соответствующей частотой. Последний шаг: проходясь от
    большей частоты к меньшей пока соответствующая очередь не пуста удаляем из нее минимум и помещаем его массив.
    Решение(как и любое решение с помощью хэш-таблиц) является компромиссом между использованием памяти и временем.
    С одной стороны затрачено больше памяти, чем могло быть затрачено при других сортировках, с другой стороны данный
    способ эффективнее по времени чем все другие сортировки(для 10000000 элементов QuickSort справляется за 12.885 с в среднем,
    а наш алгоритм для 1000000 с максимально возможной частотой для каждого ключа 10 справляется за 6.501 с в среднем).
 */
public class Main {

    public static void main(String[] args) {
	    SeparateChainingHashST_<Time_,Integer> st = new SeparateChainingHashST_<>();
	    int SIZE = 1000000, maxfreq = 1,FREQ = 10;
        Time_[] ts = new Time_[SIZE];
        Stopwatch time = new Stopwatch();
        for (int i = 0; i < SIZE; i++) {//добавляем 10000 ключей в таблицу
            ts[i] = new Time_();
            int j;
            for (j = 0; j < StdRandom.uniform(FREQ)+1; j++) {//каждый ключ поместится в таблицу от 1 до FREQ раз(имитируем что некоторые ключи встречаются несколько раз)
                st.putforfrequency(ts[i],1);//в итоге получим таблицу ключей, значение для каждого ключа явлется его частотой
            }
            if (j > maxfreq) maxfreq = j;
        }//этот блок нужен для того, чтобы имитировать массив(помещенный в таблицу), в котором будет SIZE различных ключей, при этом каждый будет встречаться от 1 до 10 раз
         // мы уже знаем сколько раз будет встречаться каждый ключ, проходить по массиву и считать не нужно
        MinPQueue_<Time_>[] minpqs = new MinPQueue_[FREQ+1];
        for (int i = 1; i < maxfreq+1; i++) {
            minpqs[i] = new MinPQueue_<>(SIZE);
        }
        for (int i = 0; i < SIZE; i++) {
            minpqs[st.get(ts[i])].insert(ts[i]);
        }
        for (int i = 0; i < SIZE; i++) {
            if (!minpqs[maxfreq].isEmpty())
                ts[i] = minpqs[maxfreq].delMin();
            if (minpqs[maxfreq].isEmpty())
                maxfreq--;
            StdOut.print("Ключ " + ts[i] + " встречается " + st.get(ts[i]));
            if (st.get(ts[i]) == 2 || st.get(ts[i]) == 3 || st.get(ts[i]) == 4)
                StdOut.println(" раза.");
            else StdOut.println(" раз.");
        }
        long usedBytes = Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory();
        StdOut.println("Массив отсортирован по частоте за " + time.elapsedTime() + " с. ");
    }
}
